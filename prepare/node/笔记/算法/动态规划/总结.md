# 动态规划
动态规划问题主要分为三类：`0-1背包`、`完全背包`、`多重背包`
## 0-1背包
1. 概念
	- 有n件物品（每件物品只能用一次）和一个最多能背重量为w的背包。第i件物品的重量是weight[i],价值是value[i],每件物品只能用一次，求解将哪些物品装入背包中物品价值总和最大？
2. 实例   
    |  	      |	   重量  |	价值	|
    | :-----: | :-------:| :-----: |
    | 物品0    |     1  |   15      |
    | 物品1     |   3   |   20      |
    | 物品2     |   4   |   30      |

    背包最大重量为4。问背包能背的物品最大价值是多少？
3. dp
    - dp[i][j]表示从下标为0-i的物品中选取不超过容量j的最大价值总和
    - dp[i][j]不放物品：dp[i-1][j]表示背包容量为j，里面不放物品i的最大价值。
    - dp[i][j]放物品：dp[i][j]=dp[i-1][j-weight[i]]+value[i](物品i的价值)。其中，dp[i-1][j-weight[i]]表示减去物品i的重量(j-weight[i])背包能得到的最大价值。
    - 之后再推导出dp[i][j]的最大值，是放入物品i还是不放入物品i
4. 二维dp数组初始化
```js
let weight = {1,3,4}
let value = {15,20,30}
let dp = new Array(weight.length).fill(0).map(() => {return Array(bagWeight).fill(0)})
``` 
5. 遍历顺序
```js
for(let i=1;i<weight.size();i++)                      // 遍历物品
{
    for(let j=0;j<=bagWeight;j++)                     // 遍历背包容量
    {
        if(j<weight[i])                               // 可通过下方例子验证
            dp[i][j]=dp[i-1][j];
        else
            dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]);
    }
}
```
6. 一维dp数组
对于背包问题其实状态都是可以压缩的。
在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);
与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。
这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。
dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
7. 初始化
```js
let dp = new Array(bagWeight.length+1).fill(0)
```
8. 遍历顺序
```js
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```
## 完全背包问题
1. 概念
    - 完全背包问题描述：有编号分别为a,b,c,d的四件物品，它们的重量分别是2,3,4,7，它们的价值分别是1,3,5,9，每件物品数量无限个，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和
    - 完全背包问题与01背包问题的区别在于每一件物品的数量都有无限个，而01背包每件物品数量只有一个
2. 实例   
    |  	      |	   重量  |	价值	|
    | :-----: | :-------:| :-----: |
    | 物品0    |     1  |   15      |
    | 物品1     |   3   |   20      |
    | 物品2     |   4   |   30      |
    
    背包最大重量为4,每件商品有无限个。问背包能背的物品最大价值是多少？
3. 0-1背包和完全背包的唯一不同体现在遍历顺序上
    ```js
    // 0-1背包遍历方式，内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    // 而完全背包的物品是可以添加多次的，所以要从小到大去遍历
    // 先遍历物品，再遍历背包
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

        }
    }
    ```
## 多重背包问题
1. 概念
    - 多重背包问题描述：有编号分别为a,b,c的三件物品，它们的重量分别是1，2，2，它们的价值分别是6，10，20，他们的数目分别是10，5，2，现在给你个承重为 8 的背包，如何让背包里装入的物品具有最大的价值总和
    - 多重背包和01背包、完全背包的区别：多重背包中每个物品的个数都是给定的，可能不是一个，绝对不是无限个