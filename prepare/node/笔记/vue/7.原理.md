### vue原理
#### 基本原理
* 当一个vue实例创建时，vue会遍历data中的属性，用object.defineProperty将他们转化为getter/setter。并在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件都有相应的watcher程序实例，他会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时。会通知watcher重新计算，从而致使它关联的组件得以更新。

#### 双向绑定原理
【数据劫持】 结合 【发布者-订阅者模式】
通过Object.defineProperty来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调
1. 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上getter和setter，这样的话给这个对象的某个值赋值，就会触发setter
2. compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
3. watcher订阅者是observer和compile之间通信的桥梁
    * 在自身实例化时往属性订阅器（dep）里面添加自己
    * 自己必须有一个update方法
    * 待属性变动dep.notice()通知时，能调用自身update方法，并触发compile中绑定的回调
4. MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果

#### 使用Object.defineProperty对数据进行劫持有什么缺点？
在对一些属性进行操作时，使用这种方法无法拦截

#### v-model的原理
1. 作用在表单元素上，动态绑定了input的value，并触发input事件
2. 作用在组件上，在自定义组件中，v-model默认会利用名为value的prop和名为input的事件
3. v-model本质上是一个父子组件通信的语法糖，通过prop和$emit实现
```html
<child :value="message" @input="function(e){message = e}"></child>
```
4. v-model也可以作用在自定义组件上

#### keep-alive原理及理解
1. keep-alive的属性
   * include 字符串或者正则表达式，只有匹配上的才会被缓存
   * exclude 字符串或者正则表达式，任何名称匹配的都不会被缓存
   * max 最多可以被缓存的组件

#### $nextTick原理
1. vue的nextTick其本质是对JavaScript执行原理EventLoop的一种应用
2. nextTick的核心是利用了如promise、MutationObserver、setImmediate、setTimeout的原生js方法来模拟对应的微、宏任务的实现
3. 其本质是为了利用js的这些异步回调任务队列来实现vue框架中自己的异步回调队列
4. nextTick不仅是vue内部的异步队列的调用方法，同时也允许开发者在实际项目的使用这个方法来满足实际应用中对DOM更新数据时机的后续逻辑处理
5. nextTick属于引入异步更新队列机制
   * 如果是同步更新，则多次对一个或多个属性赋值，会频繁触发UI/DOM的渲染，可以减少一些无用的渲染
   * 由于VirtualDOM的引入，每一次状态发生改变后，状态变化的信号会发送给组件，组价内部使用VirtualDOM进行计算得出需要更新的具体DOM节点，然后对dom进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功浪费更多的性能，所以需要异步渲染
6. nextTick使用场景：
   * 在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构时，这个操作需要方法在nextTick的回调函数中
   * 如果需要在created()钩子函数中进行DOM操作，也要放在nextTick中，因为此时页面的DOM还没有渲染