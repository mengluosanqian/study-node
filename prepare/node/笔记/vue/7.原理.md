### vue原理
#### 基本原理
* 当一个vue实例创建时，vue会遍历data中的属性，用object.defineProperty将他们转化为getter/setter。并在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件都有相应的watcher程序实例，他会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时。会通知watcher重新计算，从而致使它关联的组件得以更新。

#### 双向绑定原理
【数据劫持】 结合 【发布者-订阅者模式】
通过Object.defineProperty来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调
1. 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上getter和setter，这样的话给这个对象的某个值赋值，就会触发setter
2. compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
3. watcher订阅者是observer和compile之间通信的桥梁
    * 在自身实例化时往属性订阅器（dep）里面添加自己
    * 自己必须有一个update方法
    * 待属性变动dep.notice()通知时，能调用自身update方法，并触发compile中绑定的回调
4. MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果

#### 使用Object.defineProperty对数据进行劫持有什么缺点？
在对一些属性进行操作时，使用这种方法无法拦截

#### v-model的原理
1. 作用在表单元素上，动态绑定了input的value，并触发input事件
2. 作用在组件上，在自定义组件中，v-model默认会利用名为value的prop和名为input的事件
3. v-model本质上是一个父子组件通信的语法糖，通过prop和$emit实现
```html
<child :value="message" @input="function(e){message = e}"></child>
```
