# 算法题复习
1. 合并两个排序的链表
2. 两个链表的第一个公共节点

# 面经
## 第一篇
https://juejin.cn/post/7076676933697667085
1. 为什么 marign 0 auto 无法使块级元素垂直居中
    - 垂直方向上默认没有剩余的空间
2. z-index
3. 元素替换概念
    - 可替换原色的展示效果不是由css来控制的，这些元素是一种外部对象，他们外观的渲染，是独立于css的
    - `<iframe>、<video>、<img>、<embed>`
4. css 如何实现一个正方形盒子（随父元素）自适应
    - 宽高设置成vw
    - 设置盒子的padding-bottom样式，让盒子的padding-bottom和盒子的宽度一样，同时设置heigh = 0px；
5. 暂时性死区--答出块级作用域
6. map和weakMap
    - weakMap没有遍历相关方法
    - map可以用js任意类型作为键，weakMap只能是对象
    - 垃圾回收不会回收weakMap
7. Object.assign
    - 浅拷贝
    - 但是如果第一层是基本数据类型，修改新对象里面的数据，老数据也会发生改变
    - Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。
8. this指向
```js
var count = 100;
    var obj = {
        count: 200,
        getCount: function() {
            console.log(this.count);
        }
    }

    const c = obj.getCount;
    obj.getCount();
    c();
```
9. promise.all
    - promise.all的数据是顺序执行的，与同步异步任务无关，与宏任务、微任务无关
```js
var p1 = new Promise((resolve) => {
        resolve(1);
    });
    var p2 = new Promise((resolve) => {
        setTimeout(() => {
            resolve(2);
        }, 10000);
    });
    var p3 = new Promise((resolve) => {
        resolve(3);
    });
    Promise.all([p1, p2, p3]).then((res) => {
        console.log(res);
    });
```
10. GC机制
    - 引用计数法
        + 初始时对象的引用值为1，当被引用时，引用值加1，执行时将对象放入执行栈，执行完成时，执行栈中的对象销毁，同时引用减1，执行完成时，自动回收引用值为0的对象
    - 标记清除法
        + 垃圾收集器在运行时会给存储在内存中的所有变量都加上标记
        + 然后去除掉运行环境中的变量和被环境中变量所引用的变量的标记
        + 此后依然有标记的变量就被视为准备删除的变量，原因是运行环境中已经无法访问到这些变量
        + 销毁带标记的变量并回收所占用的内存空间

# 手写
1. call、apply、bind
2. setTimeout、setInterval相互实现

# 待复习
1. 继承