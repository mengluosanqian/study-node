# 算法题
1. 最小的k个数
# 面经
## 第一篇
https://juejin.cn/post/6844903744518389768 模块化
1. 进化过程
    - 全局function
    - namespace模式
    - 匿名函数自调用（闭包）
2. 模块化优点
    - 避免命名冲突
    - 更好的分离，按需加载
    - 更高的复用性
    - 高可维护性
3. 引入多个script后出现的问题
    - 请求过多
    - 依赖模糊
    - 难以维护
详见 prepare\node\笔记\JS\9.组件化和模块化.md


# 原理性
1. 三次握手
    ##### 第一次握手
        1. 客户端给服务端发一个SYN报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于SYN_SEND状态
        2. 首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号
        3. 传值：SYN=1,seq=x（`seq初始序号`）
    ##### 第二次握手
        1. 服务器收到客户端的SYN报文后，会以自己的SYN报文作为应答，并指明客户端的初始化序列号 ISN(s)
        2. 同时把客户端的ISN+1作为ACK的值，表示自己已经接收到客户端的SYN，此时服务器处于SYN_RCVD的状态
        3. 传值：SYN=1,ACK=1,ack=x+1(`确认号字段`),seq=y
    ##### 第三次握手
        1. 客户端收到SYN报文之后，会发送一个ACK报文，把服务器的ISN+1作为ACK的值，表示已经收到服务端的SYN报文
        2. 此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。
        3. 传值：ACK=1,ack=y+1,seq=x+1

2. 四次挥手
    ##### 第一次挥手
        1. 客户端发送一个FIN报文，报文中会指定一个序列号，此时客户端处于FIN_WAIT1状态（终止等待）
        2. 停止再发送数据，主动关闭TCP连接，进入终止等待状态，等待服务端的确认
        3. 传值: `连接释放报文`（FIN=1,序号seq=u）
    ##### 第二次挥手
        1. 服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，标明已经接受到客户端的报文了，此时服务端处于close_wait状态
        2. 服务端进入关闭等待状态，此时TCP处于半关闭状态，客户端到访问端的连接释放
        3. 客户端收到服务端的确认后，进入FIN_WAIT2(终止等待2)状态，等待服务端发出连接释放报文段
        4. 传值：`确认报文段` ACK=1,  ack=u+1,seq=v
    ##### 第三次挥手
        1. 如果服务端也想断开连接了，也发一个FIN报文，且指定一个序列号
        2. 此时服务端处于`last_ack`（最后确认）状态，即服务端没有要向客户端发出的数据
        3. 服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
        4. 传值：`连接释放报文段`FIN=1，ACK=1，序号seq=w，确认号ack=u+1
    ##### 第四次挥手
        1. 客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT（时间等待） 状态
        2. 需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
        3. 客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。
        4. 传值：确认报文段（ACK=1，seq=u+1，ack=w+1）
3. DNS协议——递归查询、迭代查询
    ### 递归查询
        1. 主机所询问的本地域名服务器不知道被查询的域名IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文（即替主机继续查询），而不是让主机自己进行下一步查询。
        2. 递归查询返回的查询结果或者时所要查询的IP地址，或者说报错，表示无法查询到所需的IP地址

    ### 迭代查询
        1. 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：‘下一步应该去哪一个域名服务器进行查询’，然后让本地服务器进行后续的查询。
        2. 根域名服务器通常是把自己知道的顶级域名服务器IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询
        3. 顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询
        4. 本地域名服务器得到了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机
# 手写
1. 快速排序
```js
function quickSort(arr) {
    if(arr.length <=1) {
        return arr
    }
    let leftArr = [],rightArr = []
    const center = arr.pop()
    for(let i = 0;i < arr.length;i++) {
        if(arr[i] < center) {
            leftArr.push(arr[i])
        }else {
            rightArr.push(arr[i])
        }
    }
    return quickSort(leftArr).concat(center,quickSort(rightArr))
}
```
# 待复习
1. webpack热更新原理 https://zhuanlan.zhihu.com/p/30669007